{"componentChunkName":"component---src-templates-blog-post-js","path":"/2014-03-24-commented-500-primes/","webpackCompilationHash":"9c13eccc252fdf34261d","result":{"data":{"markdownRemark":{"html":"<h3>Source Code</h3>\n<pre><code class=\"language-armasm\">% Algorithm P: Print table of 500 primes\nL       IS      500                 % The number of primes to find\nt       IS      $255                % Temporary storage\nn       GREG    0                   % Prime candidate\nq       GREG    0                   % Quotient\nr       GREG    0                   % Remainder\njj      GREG    0                   % Index for PRIME[j]\nkk      GREG    0                   % Index for PRIME[k]\npk      GREG    0                   % Value of PRIME[k]\nmm      IS      kk                  % Index for output lines\n        LOC     Data_Segment\nPRIME1  WYDE    2                   % PRIME[1] = 2\n        LOC     PRIME1+2*L\nptop    GREG    @                   % Address of PRIME[501]\nj0      GREG    PRIME1+2-@          % Initial value of jj\nBUF     OCTA    0                   % Place to form decimal string\n\n        LOC     #100\nMain    SET     n,3                 % P1. Start table. n &#x3C;- 3\n        SET     jj,j0               % j &#x3C;- 1\n2H      STWU    n,ptop,jj           % P2. n is prime. PRIME[j+1] &#x3C;- n\n        INCL    jj,2                % j &#x3C;- j + 1\n3H      BZ      jj,2F               % P3. 500 found?\n4H      INCL    n,2                 % P4. Advance n\n5H      SET     kk,j0               % P5. k &#x3C;- 2 / k = ptop - kk\n6H      LDWU    pk,ptop,kk          % P6. n / PRIME[k] ?\n        DIV     q,n,pk              % q &#x3C;- floor(n / PRIME[k])\n        GET     r,rR                % r &#x3C;- n mod PRIME[k]\n        BZ      r,4B                % To P4 if r = 0 for checking the next n\n7H      CMP     t,q,pk              % P7. PRIME[k] large?\n        BNP     t,2B                % To P4 if q &#x3C;= PRIME[k]\n8H      INCL    kk,2                % P8. Advance k. k &#x3C;- k + 1\n        JMP     6B                  % To P6.\n        GREG    @                   % Base address\nTitle   BYTE    \"First Five Hundred Primes\"\nNewLn   BYTE    #a,0\nBlanks  BYTE    \"   \",0             % String of three blanks\n2H      LDA     t,Title             % P9. Print Title\n        TRAP    0,Fputs,StdOut\n        NEG     mm,2\n3H      ADD     mm,mm,j0            % P10. Print line\n        LDA     t,Blanks            % Output \"   \".\n        TRAP    0,Fputs,StdOut\n2H      LDWU    pk,ptop,mm          % pk &#x3C;- prime to be printed\n0H      GREG    #2030303030000000   % \" 0000\",0,0,0\n        STOU    0B,BUF              % Prepare buffer for decimal conversion\n        LDA     t,BUF+4             % t &#x3C;- position of units digit\n1H      DIV     pk,pk,10            % pk &#x3C;- floor(pk/10)\n        GET     r,rR                % r &#x3C;- next digit\n        INCL    r,'0'               % r &#x3C;- ASCII digit r\n        STBU    r,t,0               % Store r in the buffer\n        SUB     t,t,1               % Move one byte to the left\n        PBNZ    pk,1B               % Repeat on remaining digits\n        LDA     t,BUF               % Output \" \" and four digits\n        TRAP    0,Fputs,StdOut\n        INCL    mm,2*L/10           % Advance by 50 wydes\n        PBN     mm,2B\n        LDA     t,NewLn             % Output a newline\n        TRAP    0,Fputs,StdOut\n        CMP     t,mm,2*(L/10-1)     % P11. 500 printed?\n        PBNZ    t,3B                % To P10 if not done\n        TRAP    0,Halt,0\n</code></pre>\n<h3>시작에 앞서...</h3>\n<p>코드의 각 필드는 다음을 의미한다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">line number</th>\n<th align=\"left\">LABEL</th>\n<th align=\"left\">OP</th>\n<th align=\"left\">EXPR</th>\n<th align=\"left\">Comments</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">02</td>\n<td align=\"left\">L</td>\n<td align=\"left\">IS</td>\n<td align=\"left\">500</td>\n<td align=\"left\">% The number of primes to find</td>\n</tr>\n</tbody>\n</table>\n<h4>Line 01</h4>\n<pre><code>01 % Algorithm P: Print table of 500 primes\n</code></pre>\n<p>%로 시작하는 01은 주석으로 어셈블리 코드에 영향을 주지 않는다.</p>\n<h3>전역 레지스터 선언과 초기화</h3>\n<h4>Line 02 ~ 03</h4>\n<pre><code>02 L       IS      500             % The number of primes to find\n03 t       IS      $255            % Temporary storage\n</code></pre>\n<blockquote>\n<p>..., the pseudo-operation <code>IS</code> sets the equivalent of a symbol.</p>\n</blockquote>\n<p>Pseudo-operation <code>IS</code>는 심볼의 값을 설정한다.</p>\n<p>02에서 <code>L</code>은 500으로 설정된다. 이 값은 우리가 찾을 소수의 갯수이다.\n03에서 <code>t</code>의 값은 $255 레지스터이다.</p>\n<p>심볼들은 $0 ~ $255 범위의 레지스터 값을 갖거나, 8바이트의 숫자값을 가질 수 있다.</p>\n<p>일반적으로 레지스터를 나타내는 심볼은 소문자로 시작하고, 순수한 값을 나태내는 심볼은 대문자를 사용한다.</p>\n<h4>Line 04 ~ 09</h4>\n<pre><code>04 n       GREG    0               % Prime candidate\n05 q       GREG    0               % Quotient\n06 r       GREG    0               % Remainder\n07 jj      GREG    0               % Index for PRIME[j]\n08 kk      GREG    0               % Index for PRIME[k]\n09 pk      GREG    0               % Value of PRIME[k]\n</code></pre>\n<blockquote>\n<p>The pseudo-op <code>GREG</code> on line 04 allocates a global register.</p>\n</blockquote>\n<p>Pseudo-operation <code>GREG</code>는 전역 레지스터를 할당한다.</p>\n<p>$255 레지스터는 항상 전역 레지스터이다.</p>\n<p>04의 <code>GREG</code>는 $254를 전역 레지스터로 만든다. 05도 마찬가지로 $253에 대해서 그러하다. 따라서 04에서 09까지 총 6개의 전역 레지스터가 할당된다. 그리고 n, q, r, jj, kk, pk는 각 레지스터와 동일하다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Symbol</th>\n<th align=\"center\">Global Register</th>\n<th align=\"center\">Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">n</td>\n<td align=\"center\">$254</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">q</td>\n<td align=\"center\">$253</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">r</td>\n<td align=\"center\">$252</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">jj</td>\n<td align=\"center\">$251</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">kk</td>\n<td align=\"center\">$250</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">pk</td>\n<td align=\"center\">$249</td>\n<td align=\"center\">0</td>\n</tr>\n</tbody>\n</table>\n<p><code>GREG</code> 정의의 EXPR 필드가  <strong>0</strong>이면, 해당 전역 레지스터는 프로그램이 실행될 때 동적으로 변하는 값을 갖는다고 가정한다.</p>\n<p>14, 15, 34, 45와 같이 0이 아닌 식이 주어지면, 해당 전역 레지스터는 프로그램이 실행되는 동안 상수값을 갖는다.</p>\n<h4>Line 10</h4>\n<pre><code>10 mm      IS      kk              % Index for output lines\n</code></pre>\n<p>08줄에 따라 mm은 $250와 동일하다.</p>\n<h4>Line 11</h4>\n<pre><code>11         LOC     Data_Segment\n</code></pre>\n<blockquote>\n<p><code>Location LOC Expression</code> : Continue to assemble instructions or data at the position in memory given by Expression. Often used Expressions are: #100 (where programs start) or Data_Segment. -- MMIX Quick Reference Card \"Assembler Directives\"</p>\n</blockquote>\n<p>Pseudo-operation <code>LOC</code>는 <code>EXPR</code>에 의해 주어진 <strong>메모리의 위치</strong>에서 어셈블리 명령 또는 데이터가 계속됨을 의미한다.</p>\n<p>Data_Segment는 MMIXAL에서 편의상 #2000 0000 0000 0000 (보기 편의상 4자리 마다 공백 문자를 넣었음. 실제로는 붙여써야 함)로 미리 정의되어 있다.</p>\n<h4>Line 12</h4>\n<pre><code>12 PRIME1  WYDE    2               % PRIME[1] = 2\n</code></pre>\n<p><code>WYDE</code>는 2바이트 메모리를 할당하고 <code>EXPR</code>의 결과로 로 초기화 한다. 그리고 <code>LABEL</code>은 할당된 주소의 이름이 된다. 그리하야 <code>Data_Segment</code> 영역에 소수를 저장할 공간의 시작 주소에 <code>PRIME1</code> 이라는 이름이 붙었고, 거기에 첫번째 소수인 2가 저장되었다.</p>\n<h4>Line 13 ~ Line 15</h4>\n<pre><code>13         LOC     PRIME1+2*L\n14 ptop    GREG    @               % Address of PRIME[501]\n15 j0      GREG    PRIME1+2-@      % Initial value of jj\n</code></pre>\n<p>전역 레지스터 ptop에 PRIME1으로 부터 1000 bytes 떨어진 메모리의 주소를 저장한다.</p>\n<p>그리고 전역 레지스터 ptop, j0에 아래와 같은 값이 초기화 된다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Symbol</th>\n<th align=\"center\">Global Register</th>\n<th align=\"center\">Value</th>\n<th align=\"left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">ptop</td>\n<td align=\"center\">$248</td>\n<td align=\"center\">#20000000000003e8</td>\n<td align=\"left\">PRIME1+1000</td>\n</tr>\n<tr>\n<td align=\"center\">j0</td>\n<td align=\"center\">$247</td>\n<td align=\"center\">-998</td>\n<td align=\"left\">PRIME1+2-(PRIME1+1000)</td>\n</tr>\n</tbody>\n</table>\n<h4>Line 16</h4>\n<pre><code>16 BUF     OCTA    0               % Place to form decimal string\n</code></pre>\n<p>이 후 결과 출력을 위해 십진수 숫자를 저장할 문자열 버퍼로 메모리에 8 byte를 할당하고 0으로 초기화 한다. 그리고 그 주소의 이름은 <code>BUF</code>.</p>\n<h3>소수 구하기</h3>\n<h4>Line 18</h4>\n<pre><code>18         LOC     #100\n</code></pre>\n<p>user space address #0000 0000 0000 0100에 아래 코드가 위치한다.</p>\n<h4>Line 19 ~ 20</h4>\n<pre><code>19 Main    SET     n,3             % P1. Start table. n &#x3C;- 3\n20         SET     jj,j0           % j &#x3C;- 1\n</code></pre>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Symbol</th>\n<th align=\"center\">Global Register</th>\n<th align=\"center\">Previous Value</th>\n<th align=\"center\">Current Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">n</td>\n<td align=\"center\">$254</td>\n<td align=\"center\">0</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">jj</td>\n<td align=\"center\">$251</td>\n<td align=\"center\">0</td>\n<td align=\"center\">-998</td>\n</tr>\n<tr>\n<td align=\"center\">j0</td>\n<td align=\"center\">$247</td>\n<td align=\"center\">-998</td>\n<td align=\"center\">-998</td>\n</tr>\n</tbody>\n</table>\n<h4>Line 21 ~ 33</h4>\n<p>소수를 찾는 루프 부분.</p>\n<pre><code>21 2H      STWU    n,ptop,jj       % P2. n is prime. PRIME[j+1] &#x3C;- n\n22         INCL    jj,2            % j &#x3C;- j + 1\n23 3H      BZ      jj,2F           % P3. 500 found?\n24 4H      INCL    n,2             % P4. Advance n\n25 5H      SET     kk,j0           % P5. k &#x3C;- 2 / k = ptop + kk\n26 6H      LDWU    pk,ptop,kk      % P6. n / PRIME[k] ?\n27         DIV     q,n,pk          %       q &#x3C;- floor(n / PRIME[k])\n28         GET     r,rR            %       r &#x3C;- n mod PRIME[k]\n29         BZ      r,4B            % To P4 if r = 0 for checking the next n\n30 7H      CMP     t,q,pk          % P7. PRIME[k] large?\n31         BNP     t,2B            % To P4 if q &#x3C;= PRIME[k]\n32 8H      INCL    kk,2            % P8. Advance k. k &#x3C;- k + 1\n33         JMP     6B              % To P6.\n</code></pre>\n<p>21번 줄에서는 n = 3이고, 3이 소수이므로 n을 PRIME[ptop + jj]에 저장한다. 뒤의 31번 줄에서 소수를 찾았을 때 2H로 브랜치하여 n을 저장한다.</p>\n<p>22번 줄에서는 jj를 2만큼 증가시켜 다음 소수가 저장될 위치에 대한 인덱스로 사용할 수 있게 한다.</p>\n<p>23번 줄에서는 jj가 0이되면 500개의 소수가 모두 구해진 것으로 이 경우에는 \"2 Forward\"로 2H 라벨이 붙은 44줄로 이동한다.</p>\n<p>24번 줄에서는 홀수만 검사하기 위해 n을 2씩 증가 시킨다.</p>\n<p>25번 줄에서는 n이 현재까지 찾은 소수로 나눠지는지 검사하기 위해 나눠볼 소수에 대한 인덱스로 kk를 사용한다. k = ptop + kk. n은 홀수이므로 ptop에 있는 2로는 나눠볼 필요가 없기  때문에 kk를 j0로 설정한다.</p>\n<p>26번 줄에서는 메모리에 있는 k번째 소수를 로드한다. pk = M[ptop + kk] 값이 설정된다.</p>\n<p>27번 줄에서 n을 pk로 나눈 몫을 q에 저장한다.</p>\n<p>28번 줄에서는 레지스터 r(g#252)로 rR(remainder register)의 값을 가져온다.</p>\n<p>29번 줄에서는 r이 0인지 여부를 검사하는데, r이 0이라는 것은 n이 소수로 나눠진다는 것을 의미하므로 n은 소수가 아니다. 때문에 다음 소수를 검사하기 위해 \"4 backward\" 하여 24번 줄로 이동한다.</p>\n<p>30번 줄에서는 q와 pk의 값을 비교하는데 만약 q &#x3C;= pk 이면 n은 소수이다. 이에 대한 증명은 연습문제 11번을 참고.</p>\n<p>31번 줄에서는 q&#x3C;= pk인 경우 t &#x3C;= 0이 되므로 n은 소수로 판정되고 n을 저장하기 위해 \"2 backward\"인 21번 줄의 2H 라벨로 이동한다.</p>\n<p>32번 줄에서는 n이 소수인지 아직 알 수 없으므로  다음 소수로 나눠보기 위해서 kk를 2만큼 증가시킨다.</p>\n<p>33번 줄에서는 pk[ptop + kk]로 n을 나눠보기 위해서 \"6 backward\"인 26번 줄의 6H 라벨로 이동한다.</p>\n<h3>테이블 출력</h3>\n<p>결과가 출력되는 형식은 다음과 같다.</p>\n<pre><code>First Five Hundred Primes\nFirst Five Hundred Primes\n    0002 0233 0547 0877 1229 1597 1993 2371 2749 3187\n    0003 0239 0557 0881 1231 1601 1997 2377 2753 3191\n    0005 0241 0563 0883 1237 1607 1999 2381 2767 3203\n    ...\n    0229 0541 0863 1223 1583 1987 2357 2741 3181 3571\n</code></pre>\n<h4>Line 34 ~ 37</h4>\n<pre><code>34         GREG    @               % Base address\n35 Title   BYTE    \"First Five Hundred Primes\"\n36 NewLn   BYTE    #a,0\n37 Blanks  BYTE    \"   \",0         % String of three blanks\n</code></pre>\n<p>메모리에 출력에 필요한 문자열들을 위한 메모리를 할당하고 초기화한다.</p>\n<h4>Line 38 ~ 39</h4>\n<pre><code>38 2H      LDA     t,Title         % P9. Print Title\n39         TRAP    0,Fputs,StdOut\n</code></pre>\n<p>타이틀을 출력한다.</p>\n<h4>Line 40 ~ 61</h4>\n<pre><code>40         NEG     mm,2            % Initialize m.\n41 3H      ADD     mm,mm,j0        % P10. Print line\n42         LDA     t,Blanks        % Output \"   \".\n43         TRAP    0,Fputs,StdOut\n44 2H      LDWU    pk,ptop,mm      % pk &#x3C;- prime to be printed\n45 0H      GREG    #2030303030000000       % \" 0000\",0,0,0\n46         STOU    0B,BUF          % Prepare buffer for decimal conversion\n47         LDA     t,BUF+4         % t &#x3C;- position of units digit\n48 1H      DIV     pk,pk,10        % pk &#x3C;- floor(pk/10)\n49         GET     r,rR            % r &#x3C;- next digit\n50         INCL    r,'0'           % r &#x3C;- ASCII digit r\n51         STBU    r,t,0           % Store r in the buffer\n52         SUB     t,t,1           % Move one byte to the left\n53         PBNZ    pk,1B           % Repeat on remaining digits\n54         LDA     t,BUF           % Output \" \" and four digits\n55         TRAP    0,Fputs,StdOut\n56         INCL    mm,2*L/10       % Advance by 50 wydes\n57         PBN     mm,2B\n58         LDA     t,NewLn         % Output a newline\n59         TRAP    0,Fputs,StdOut\n60         CMP     t,mm,2*(L/10-1) % P11. 500 printed?\n61         PBNZ    t,3B            % To P10 if not done\n</code></pre>\n<p>40번 줄에서는 mm(g#250)을 -2로 설정.</p>\n<p>41번 줄에서는 mm = mm + j0로 설정</p>\n<p>42번 ~ 43번 줄에서는 출력 라인의 첫 시작인 공백문자 3개를 출력한다.</p>\n<p>44번 줄에서는 출력할 소수를 pk로 가져온다. pk는 PRIMES[ptop + mm].</p>\n<p>45번 줄에서는 숫자를 문자열로 변환하기 위한 문자열을 위한 전역 레지스터를 할당한다.</p>\n<p>46번 줄에서는 45번에 선언한 문자열을 BUF에 저장한다.</p>\n<p>47번 줄에서는 t가 BUF + 4의 위치를 가리키도록 한다.</p>\n<pre><code>\" 0000\"\n     ^\n     t\n</code></pre>\n<p>48번 줄에서는 pk를 10으로 나눈 몫을 pk에 저장한다.</p>\n<p>49번 줄에서는 pk의 나머지(digit)가 저장된 rR의 값을 r로 가져온다.</p>\n<p>50번 줄에서는 digit를 char로 변환하기 위해 r에 문자 '0'을 더해준다.</p>\n<p>51번 줄에서는 이렇게 변환된 digit을 버퍼에 저장한다.</p>\n<p>52번 줄에서는 t에서 1을 빼서 앞의 자릿수로 이동시킨다.</p>\n<pre><code>\" 0002\"\n    ^\n    t\n</code></pre>\n<p>53번 줄에서는 pk이가 0이 아닌 경우, 출력할 자릿수가 더 남았다는 의미이므로 \"1 backward\"인 48번줄의 1H 라벨로 이동한다.</p>\n<p>54~55번 줄에서는 BUF에 저장된 소수를 출력한다.</p>\n<p>56번 줄에서는 다음에 출력할 소수의 위치를 계산하는데 소수 테이블이 row가 50고, column이 10이라, 현재 숫자에서 다음 50번째 숫자를 출력하기 위해 mm을 2 * L / 10 만큼 증가 시킨다.</p>\n<p>57번 줄에서 mm이 음수면 현재 줄에 출력한 소수가 남았다는 의미로 \"2 backward\"인 44번줄로의 2H 라벨로 이동한다.</p>\n<p>58~59번 줄은 10개의 소수를 다 출력하고 난 후, 개행문자를 출력해준다.</p>\n<p>60번 줄에서는 mm이 마지막 소수를 가리키는 위치인지 검사한다.</p>\n<p>61번 줄에서는 mm과 마지막 소수의 위치가를 비교한 경과가 같지 않은 경우(0이 아닌 경우), \"3 backward\"인 41번 줄의 3H 라벨로 이동한다.</p>\n<p>mm의 값의 변화는 다음과 같다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Line</th>\n<th align=\"right\">c00</th>\n<th align=\"right\">c01</th>\n<th align=\"right\">c02</th>\n<th align=\"right\">c03</th>\n<th align=\"right\">c04</th>\n<th align=\"right\">c05</th>\n<th align=\"right\">c06</th>\n<th align=\"right\">c07</th>\n<th align=\"right\">c08</th>\n<th align=\"right\">c09</th>\n<th align=\"right\">-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"right\">-1000</td>\n<td align=\"right\">-900</td>\n<td align=\"right\">-800</td>\n<td align=\"right\">-700</td>\n<td align=\"right\">-600</td>\n<td align=\"right\">-500</td>\n<td align=\"right\">-400</td>\n<td align=\"right\">-300</td>\n<td align=\"right\">-200</td>\n<td align=\"right\">-100</td>\n<td align=\"right\">0</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"right\">-998</td>\n<td align=\"right\">-898</td>\n<td align=\"right\">-798</td>\n<td align=\"right\">-698</td>\n<td align=\"right\">-598</td>\n<td align=\"right\">-498</td>\n<td align=\"right\">-398</td>\n<td align=\"right\">-298</td>\n<td align=\"right\">-198</td>\n<td align=\"right\">-98</td>\n<td align=\"right\">2</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"right\">-996</td>\n<td align=\"right\">-896</td>\n<td align=\"right\">-796</td>\n<td align=\"right\">-696</td>\n<td align=\"right\">-596</td>\n<td align=\"right\">-496</td>\n<td align=\"right\">-396</td>\n<td align=\"right\">-296</td>\n<td align=\"right\">-196</td>\n<td align=\"right\">-96</td>\n<td align=\"right\">4</td>\n</tr>\n</tbody>\n</table>\n<h3>프로그램 종료</h3>\n<h4>Line 62</h4>\n<pre><code>62         TRAP    0,Halt,0\n</code></pre>\n<p>프로그램을 종료한다.</p>","frontmatter":{"title":"500 Primes","date":"24 March, 2014"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2014-03-24-commented-500-primes/"}}}